/*
MIT License

Copyright (c) 2025 Marek Mach (Bastl Instruments)
Copyright (c) 2025 Vaclav Mach (Bastl Instruments)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#pragma once

#include <array>
#include <cstdint>

namespace kastle2
{

namespace midi
{
/**
 * @class Message
 * @ingroup core_midi
 * @brief Represents a MIDI message
 * @author Marek Mach (Bastl Instruments), Vaclav Mach (Bastl Instruments)
 * @date 2025-03-18
 */
class Message
{
public:
    /**
     * @brief Special value for all MIDI channels (not official MIDI value, we use it just a placeholder)
     */
    static constexpr uint8_t kAllChannels = 0xFF;

    /**
     * @brief Mask for MIDI real-time messages
     */
    static constexpr uint8_t kRealTimeMask = 0xF8;

    /**
     * @brief Mask for MIDI system messages
     */
    static constexpr uint8_t kSystemMessageMask = 0xF0;

    /**
     * @brief Minimum value for pitch bend message
     */
    static constexpr int16_t kPitchBendMin = -8192;

    /**
     * @brief Maximum value for pitch bend message
     */
    static constexpr int16_t kPitchBendMax = 8191;

    /**
     * @enum Type
     * @brief MIDI message types, with corresponding values
     */
    enum class Type
    {
        NOTE_OFF = 0x80,                ///< Note Off
        NOTE_ON = 0x90,                 ///< Note On
        AFTER_TOUCH_POLY = 0xA0,        ///< Polyphonic AfterTouch
        CONTROL_CHANGE = 0xB0,          ///< Control Change / Channel Mode
        PROGRAM_CHANGE = 0xC0,          ///< Program Change
        AFTER_TOUCH_GLOBAL = 0xD0,      ///< Channel (monophonic) AfterTouch
        PITCH_BEND = 0xE0,              ///< Pitch Bend
        SYSTEM_EXCLUSIVE = 0xF0,        ///< System Exclusive
        TIME_CODE_QUARTER_FRAME = 0xF1, ///< System Common - MIDI Time Code Quarter Frame
        SONG_POSITION = 0xF2,           ///< System Common - Song Position Pointer
        SONG_SELECT = 0xF3,             ///< System Common - Song Select
        TUNE_REQUEST = 0xF6,            ///< System Common - Tune Request
        SYSTEM_EXCLUSIVE_END = 0xF7,    ///< End of System Exclusive
        CLOCK = 0xF8,                   ///< System Real Time - Timing Clock
        START = 0xFA,                   ///< System Real Time - Start
        CONTINUE = 0xFB,                ///< System Real Time - Continue
        STOP = 0xFC,                    ///< System Real Time - Stop
        ACTIVE_SENSING = 0xFE,          ///< System Real Time - Active Sensing
        SYSTEM_RESET = 0xFF,            ///< System Real Time - System Reset
        INVALID = 0x00                  ///< For notifying errors
    };

    /**
     * @enum Source
     * @brief Source of the MIDI message, either from TRS (UART) or USB
     */
    enum class Source
    {
        NONE,    ///< No info
        TRS,     ///< MIDI message received from TRS (UART)
        USB,     ///< MIDI message received from USB
        INTERNAL ///< Internal message (generated by the Kastle2)
    };

    /**
     * @struct UsbPacket
     * @brief Represents a USB packet containing MIDI message data
     * @note The USB packet is 4 bytes long, with the first byte being the CIN (Cable and Type) byte.
     */
    union alignas(4) UsbPacket
    {
        uint32_t raw;    ///< Raw USB packet data (4 bytes)
        uint8_t data[4]; ///< USB packet data (4 bytes)
    };

    /**
     * @brief Returns the MIDI message type based on the first byte of the message
     * @param message_first_byte The first byte of the MIDI message
     * @return The type of the MIDI message in Type enum format
     */
    static Type RetrieveType(const uint8_t message_first_byte);

    /**
     * @brief Returns the number of data bytes according to the first byte of the message
     * @param message_first_byte The first byte of the MIDI message
     * @return 0, 1, 2 bytes, depending on the type of MIDI message
     * @note For example, Note On and Note Off messages have 2 data bytes, Control Change has 2 data bytes, etc.
     */
    static uint32_t RetrieveNumBytes(const uint8_t message_first_byte);

    /**
     * @brief Parses a MIDI message from TRS (UART) data
     * @param data Array of 3 bytes containing the MIDI message data
     * @return A Message object containing the parsed MIDI message
     */
    static Message ParseFromTrs(const std::array<uint8_t, 3> &data);

    /**
     * @brief Parses a MIDI message from USB data
     * @param data Array of 4 bytes containing the MIDI message data
     * @return A Message object containing the parsed MIDI message
     */
    static Message ParseFromUsb(const std::array<uint8_t, 4> &data);

    /**
     * @brief Creates an empty MIDI message
     */
    Message() : type_(Type::INVALID), channel_(kAllChannels), source_(Source::INTERNAL)
    {
        data_[0] = 0;
        data_[1] = 0;
        data_[2] = 0;
    }

    /**
     * @brief Creates a MIDI message with the specified type and channel
     * @param type The type of the MIDI message
     * @param channel The channel of the MIDI message (0-15) or kAllChannels
     * @param data1 The first data byte of the MIDI message
     * @param data2 The second data byte of the MIDI message
     */
    Message(const Type type, const uint8_t channel, const uint8_t data1 = 0, const uint8_t data2 = 0)
        : type_(type), channel_(channel), source_(Source::INTERNAL)
    {
        StoreChannelAndType();
        data_[1] = data1; // Set first data byte
        data_[2] = data2; // Set second data byte
    }

    /**
     * @brief Returns the type of message that is received
     * @return The type of received message in Type enum format
     */
    inline Type GetType() const
    {
        return type_;
    };

    /**
     * @brief Returns the channel of the received message (if it has a channel, otherwise returns 255)
     * @return The channel of the received message in uint8_t format
     */
    inline uint8_t GetChannel() const
    {
        return channel_;
    }

    /**
     * @brief Returns the first data byte of the received message
     * @return The first data byte of the received message in uint8_t format
     */
    inline uint8_t GetData1() const
    {
        return data_[1];
    }

    /**
     * @brief Returns the second data byte of the received message
     * @return The second data byte of the received message in uint8_t format
     */
    inline uint8_t GetData2() const
    {
        return data_[2];
    }

    /**
     * @brief Returns if the received message type is Note on
     * @return True if the message type is Note on and it has a non-zero velocity, false otherwise
     */
    inline bool IsNoteOn() const
    {
        return GetType() == Type::NOTE_ON && GetData2() != 0;
    }

    /**
     * @brief Returns if the received message type is Note off
     * @return True if the message type is Note off or Note on with zero velocity, false otherwise
     */
    inline bool IsNoteOff() const
    {
        return (GetType() == Type::NOTE_OFF) || (GetType() == Type::NOTE_ON && GetData2() == 0);
    }

    /**
     * @brief Returns if the received message type is Control change
     * @return True if the message type is Control change, false otherwise
     */
    inline bool IsControlChange() const
    {
        return GetType() == Type::CONTROL_CHANGE;
    }

    /**
     * @brief Returns if the received message type is a real-time clock
     * @return True if the message type is a real-time clock, false otherwise
     */
    inline bool IsClock() const
    {
        return GetType() == Type::CLOCK;
    }

    /**
     * @brief Returns if the received message type is a real-time start
     * @return True if the message type is a real-time start, false otherwise
     */
    inline bool IsStart() const
    {
        return GetType() == Type::START;
    }

    /**
     * @brief Returns if the received message type is a real-time continue
     * @return True if the message type is a real-time continue, false otherwise
     */
    inline bool IsContinue() const
    {
        return GetType() == Type::CONTINUE;
    }

    /**
     * @brief Returns if the received message type is a real-time stop
     * @return True if the message type is a real-time stop, false otherwise
     */
    inline bool IsStop() const
    {
        return GetType() == Type::STOP;
    }

    /**
     * @brief Returns if the received message type is a pitch bend
     * @return True if the message type is a pitch bend, false otherwise
     */
    inline bool IsPitchBend() const
    {
        return GetType() == Type::PITCH_BEND;
    }

    /**
     * @brief Returns the source of the MIDI message
     * @return The source of the MIDI message in Source enum format
     */
    inline Source GetSource() const
    {
        return source_;
    }

    /**
     * @brief Sets the type of the MIDI message
     * @param type NoteOn etc.
     */
    void SetType(Type type)
    {
        type_ = type;
    }
    /**
     * @brief Sets the channel of the MIDI message
     * @param channel MIDI channel (0-15) or kAllChannels
     */
    void SetChannel(uint8_t channel)
    {
        channel_ = channel;
    }

    /**
     * @brief Usually Note number, Control Change number, etc.
     * @param data1 First data byte of the MIDI message
     */
    void SetData1(uint8_t data1)
    {
        data_[1] = data1;
    }

    /**
     * @brief Usually Velocity, Control Change value, etc.
     * @param data2 Second data byte of the MIDI message
     */
    void SetData2(uint8_t data2)
    {
        data_[2] = data2;
    }

    /**
     * @brief Retuns the pitch bend value as a float in the range -1.0 to 1.0
     * @return Pitch bend value as a float (-1.0 = min, 0.0 = no pitch bend, 1.0 = max)
     */
    float GetPitchBendAsFloat() const;

    /**
     * @brief Retuns the pitch bend value as semitone based frequency multiplier
     * @param semitones_range The range of semitones for the pitch bend (e.g., 12 for one octave)
     * @return Pitch bend value as a float (1.0 = no pitch bend, 0.5 = down one octave, 2.0 = up one octave)
     */
    float GetPitchBendAsSemitones(float semitones_range) const;

    /**
     * @brief Returns the USB packet with the MIDI message data
     * @param cable_number Cable number (0-3), defaults to 0
     */
    UsbPacket GetUsbPacket(const uint8_t cable_number);

private:
    static constexpr std::array<uint8_t, 4> kReservedMessages{0xF4, 0xF5, 0xF9, 0xFD};

    Type type_ = Type::INVALID;
    uint8_t channel_ = kAllChannels;
    uint8_t data_[3] = {0, 0, 0};
    Source source_ = Source::NONE;

    /**
     * @brief Parses the `type_` and `channel_` from the first byte of the MIDI message
     */
    void ParseChannelAndType();

    /**
     * @brief Stores `type_` and `channel_` into the first byte of the MIDI message
     */
    void StoreChannelAndType();

    /**
     * @brief Generates the CIN byte for the MIDI message
     * @param type The type of the MIDI message
     * @param cable_number The cable number (0-3)
     * @return The generated CIN byte
     */
    static uint8_t GenerateCinByte(const Type type, const uint8_t cable_number);
};
}
}
