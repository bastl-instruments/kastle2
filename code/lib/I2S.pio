/*
 * I2S.pio
 *
 * Lightweight I2S driver for the Raspberry Pi Pico (RP2040)
 * Author: Vaclav Mach (Bastl Instruments)
 * Date: July 2025
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * Inspiration and Derivation:
 *
 * - Portions of this code were derived from the I2S implementation in
 *   the Arduino-Pico core by Earle F. Philhower, III
 *   Copyright (c) 2022 Earle F. Philhower, III <earlephilhower@yahoo.com>
 *   https://github.com/earlephilhower/arduino-pico
 *   Licensed under the GNU Lesser General Public License v2.1
 *
 * - This implementation was also inspired by the structure and behavior of
 *   "rp2040_i2s_example" by Daniel Collins (GPL-3.0 licensed)
 *   https://github.com/malacalypse/rp2040_i2s_example
 *   No code from that project was copied; this implementation was written
 *   independently from scratch using original techniques.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */

.program i2s_mclk
; PIO SM clock is MCLK x 2
; MCLK/BCLK sync is maintained by ensuring IN/OUT PIO SM clock dividers 
; are x128, 384, 256, 512 or 768 multiples of MCLK SM divider as required.

loop_mclk:
    set pins, 1 ; toggle mclk
    set pins, 0 
    ; Loop back to beginning...
    

.program i2s_dout
.side_set 2 ; 0 = bclk, 1=wclk

;                           +----- WCLK
;                           |+---- BCLK
    mov x, y         side 0b01
left1:
    out pins, 1      side 0b00
    jmp x--, left1   side 0b01
    out pins, 1      side 0b10 ; Last bit of left has WCLK change per I2S spec

    mov x, y         side 0b11
right1:
    out pins, 1      side 0b10
    jmp x--, right1  side 0b11
    out pins, 1      side 0b00 ; Last bit of right also has WCLK change
    ; Loop back to beginning...


; x = channel (0 = left, 1 = right)
.program i2s_din
start:
    set x, 0                ; Set channel to left (it's double inverted at start)
    mov osr, y              ; Store initial Y value in OSR (we don't use it for outputting)
finish_channel:
    mov x, !x               ; Swap channel
    wait 1 pin 1            ; Wait for BCLK rising
    in pins, 1              ; The first bit is actually the last bit of the previous sample
    wait 0 pin 1            ; Wait for BCLK falling
    push noblock            ; Push data to RX FIFO
    mov y, osr              ; Load bit count from OSR
read_bits:
    wait 1 pin 1            ; Wait for BCLK rising
    in pins, 1              ; Read data bit
    wait 0 pin 1            ; Wait for BCLK falling
    jmp y--, read_bits      ; Loop until all (but the special last) bits read
    jmp !x, left_done       ; Finish reading channel
right_done:
    wait 1 pin 2            ; Wait for LRCLK rising 
    jmp finish_channel
left_done:
    wait 0 pin 2            ; Wait for LRCLK falling
    jmp finish_channel
                           

% c-sdk {

inline void i2s_mclk_program_init(PIO pio, size_t sm, size_t offset, size_t mclk_pin) {
    pio_gpio_init(pio, mclk_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, mclk_pin, 1, true);
    pio_sm_config sm_config = i2s_mclk_program_get_default_config(offset);   
    sm_config_set_set_pins(&sm_config, mclk_pin, 1);
    pio_sm_init(pio, sm, offset, &sm_config);
}

inline void i2s_dout_program_init(PIO pio, size_t sm, size_t offset, size_t dout_pin, size_t clock_pin_base, size_t bits) {
    pio_gpio_init(pio, dout_pin);
    pio_gpio_init(pio, clock_pin_base);
    pio_gpio_init(pio, clock_pin_base + 1);
    pio_sm_config sm_config = i2s_dout_program_get_default_config(offset);
    sm_config_set_out_pins(&sm_config, dout_pin, 1);
    sm_config_set_sideset_pins(&sm_config, clock_pin_base);
    sm_config_set_out_shift(&sm_config, false, true, (bits <= 16) ? 2 * bits : bits);
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_TX);
    pio_sm_init(pio, sm, offset, &sm_config);
    pio_sm_set_consecutive_pindirs(pio, sm, dout_pin, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base, 2, true);
    pio_sm_set_set_pins(pio, sm, dout_pin, 1);
    pio_sm_set_set_pins(pio, sm, clock_pin_base, 2);
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, bits - 2));
}

inline void i2s_din_program_init(PIO pio, size_t sm, size_t offset, size_t din_pin, size_t bits) {
    pio_gpio_init(pio, din_pin);
    gpio_set_dir(din_pin, GPIO_IN);
    gpio_set_pulls(din_pin, false, false);
    pio_sm_config sm_config = i2s_din_program_get_default_config(offset);
    sm_config_set_in_pins(&sm_config, din_pin);
    sm_config_set_in_shift(&sm_config, false, false, 0);
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_RX);
    sm_config_set_jmp_pin(&sm_config, din_pin + 2);
    pio_sm_init(pio, sm, offset, &sm_config);
    pio_sm_set_set_pins(pio, sm, din_pin, 0);
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, bits - 2));
}

%}